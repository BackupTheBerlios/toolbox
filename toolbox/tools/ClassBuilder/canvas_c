/* -*- Mode: C; tab-width: 2; indent-tabs-mode: t; c-basic-offset: 2 -*- */
//===========================================================
// ~cvstag~
//===========================================================

// autogenerated/refactored on ~date~ by ~author~

~licence~

/**
 * @file ~class_name~.c
 */

/**
 * @defgroup ~class_name~ Class ~typedef~
 * @ingroup ~class_parent~
 * Class ~class_name~ (extends ~class_parent~~got_interfaces~)
 *
 * description :
 *
 * ... here the header description
 */


~isBUILD~

#include "Toolbox.h"
#include "Memory.h"
#include "Error.h"
#include "~class_impl_h~"
#include "tb_ClassBuilder.h"

~instanced_class_it_storage~

~methodIdentifiers~

static void *~free~(~typedef~ Self);
~declareClassMethods~

void ~setup_once~(int OID);

inline ~class_name_members_t~ ~Xclass~(~typedef~ Self) {
	return (~class_name_members_t~)((__members_t)tb_getMembers(Self, ~type_tag_T~))->instance;
}

pthread_once_t __~init_once~ = PTHREAD_ONCE_INIT;
void ~init_once~() {
	pthread_once(&__class_registry_init_once, tb_classRegisterInit);
	// if you doesn't extends directly from a toolbox class, you must call your ancestor init
	~type_tag_T~ = tb_registerNewClass("~typedef~", ~class_parent_id~, ~setup_once~);
}



void ~setup_once~(int OID) {
~registerMethods~
	/* OM_NEW and OM_FREE are mandatory methods */
	tb_registerMethod(OID, OM_NEW,                    ~class_name~_new);
  tb_registerMethod(OID, OM_FREE,                   ~free~);
~registerClassMethods~
}


~typedef~ ~class_name~_ctor(~typedef~ Self~list_ctor_args~) {
	/* specific ctor code goes here */
	return Self;
}

#if defined TB_MEM_DEBUG && (! defined NDEBUG) 
~typedef~ dbg_~class_name_ctor~(char *func, char *file, int line~list_ctor_args~) {
	set_tb_mdbg(func, file, line);
	return ~class_name~_ctor(~class_name~_new()~list_ctor_args~);
}
#endif

/** ~typedef~ constructor
 *
 * oneliner header function description
 *
 * longer description/explanation
 *
 * @param arg1 desc of arg1
 * @param argn desc of argn
 * @return descrition of return values
 *
 * @see related entries
 * @ingroup ~class_name~
 */
~typedef~ ~class_name_ctor~(~ctor_args~) {
	return ~class_name~_ctor(~class_name~_new()~list_ctor_args~);
}



~typedef~ ~class_name~_new() {
	tb_Object_t Self;
	pthread_once(&__~init_once~, ~init_once~);
	~class_name_members_t~ m;
	Self =  tb_newParent(~type_tag_T~);

	Self->isA  = ~type_tag_T~;

	m = (~class_name_members_t~)tb_xcalloc(1, sizeof(struct ~class_name_members~));
	Self->members->instance = m;

	/*  [... generic ctor code here (members init)...]	*/

	if(fm->dbg) fm_addObject(Self);

	return Self;
}

void *~free~(~typedef~ Self) {
	if(tb_valid(Self, ~type_tag_T~, __FUNCTION__)) {
    //~class_name_members_t~ m = ~Xclass~(Self);
		fm_fastfree_on();

		/*[ your dtor code here ]
		tb_xfree(m->my_own_member);
		don't free m itself : tb_freeMembers(Self) will take care of it
		*/

		tb_freeMembers(Self);
		fm_fastfree_off();
		Self->isA = ~type_tag_T~; // requiered for introspection (as we are unwinding dtors stack)
    return tb_getParentMethod(Self, OM_FREE);
	}

  return NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   start of Autogenerated interfaces for inheritable functions
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

~classMeth~

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   debug wrappers for class methods
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

~dbgClassMeth~

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Class methods local implementations
/////////////////////////////////////////////////////////////////////////////////////////////////////////////


~method_local_impl~

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    public setters & getters methods goes here
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

~setters_impl~

~getters_impl~

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//    others class methods
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

