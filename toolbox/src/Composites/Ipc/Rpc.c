/* -*- Mode: C; tab-width: 2; indent-tabs-mode: t; c-basic-offset: 2 -*- */
//===========================================================
// $Id: Rpc.c,v 1.1 2005/05/12 21:50:48 plg Exp $
//===========================================================

// autogenerated/refactored on Wed Sep 22 14:13:45 2004 by Paul L. Gatille <Paul.Gatille@free.fr>

/*
 * Copyright (c) 2004, Paul Gatille
 * This file is part of Toolbox, an object-oriented utility library
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the "Artistic License" which comes with this Kit.
 *
 * This software is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the Artistic License for more
 * details.
*/


/**
 * @file Rpc.c
 */

/**
 * @defgroup Rpc Class Rpc_t
 * @ingroup Composites
 * Class Rpc (extends Composites)
 *
 * description :
 *
 * ... here the header description
 */


#ifndef __BUILD
#define __BUILD
#endif


#include "Toolbox.h"
#include "Memory.h"
#include "Error.h"
#include "Rpc_impl.h"
#include "Composites.h"
#include "tb_ClassBuilder.h"

int RPC_T;



static void *Rpc_free(Rpc_t Self);
//-----------------------------------------------------
// Composite Class overloaded methods
//-----------------------------------------------------
//-----------------------------------------------------
// tb_Object Class overloaded methods
//-----------------------------------------------------
// static tb_Object_t     Rpc_Clone(tb_Object_t Self);
// static void            Rpc_Dump(tb_Object_t Self);
// static tb_Object_t     Rpc_Clear(tb_Object_t Self);
// static int             Rpc_Compare(tb_Object_t Self, tb_Object_t Other);
// static String_t        Rpc_Stringify(tb_Object_t Self);


void setup_Rpc_once(int OID);

inline Rpc_members_t XRpc(Rpc_t Self) {
	return (Rpc_members_t)((__members_t)tb_getMembers(Self, RPC_T))->instance;
}

pthread_once_t __init_Rpc_once = PTHREAD_ONCE_INIT;
void init_Rpc_once() {
	pthread_once(&__class_registry_init_once, tb_classRegisterInit);
	// if you doesn't extends directly from a toolbox class, you must call your ancestor init
	RPC_T = tb_registerNewClass("Rpc_t", TB_COMPOSITE, setup_Rpc_once);
}



void setup_Rpc_once(int OID) {

	/* OM_NEW and OM_FREE are mandatory methods */
	tb_registerMethod(OID, OM_NEW,                    Rpc_new);
  tb_registerMethod(OID, OM_FREE,                   Rpc_free);
	//---------------------------------------------------
	// Composite Class overloaded methods
	//---------------------------------------------------
	//---------------------------------------------------
	// tb_Object Class overloaded methods
	//---------------------------------------------------
	// 	tb_registerMethod(OID, OM_RPC_CLONE   , Rpc_Clone           );
	// 	tb_registerMethod(OID, OM_RPC_DUMP    , Rpc_Dump            );
	// 	tb_registerMethod(OID, OM_RPC_CLEAR   , Rpc_Clear           );
	// 	tb_registerMethod(OID, OM_RPC_COMPARE , Rpc_Compare         );
	// 	tb_registerMethod(OID, OM_RPC_STRINGIFY, Rpc_Stringify       );

}


Rpc_t Rpc_ctor(Rpc_t Self) {
	/* specific ctor code goes here */
	return Self;
}

#if defined TB_MEM_DEBUG && (! defined NDEBUG) 
Rpc_t dbg_Rpc(char *func, char *file, int line) {
	set_tb_mdbg(func, file, line);
	return Rpc_ctor(Rpc_new());
}
#endif

/** Rpc_t constructor
 *
 * oneliner header function description
 *
 * longer description/explanation
 *
 * @param arg1 desc of arg1
 * @param argn desc of argn
 * @return descrition of return values
 *
 * @see related entries
 * @ingroup Rpc
 */
Rpc_t Rpc() {
	return Rpc_ctor(Rpc_new());
}



Rpc_t Rpc_new() {
	tb_Object_t Self;
	pthread_once(&__init_Rpc_once, init_Rpc_once);
	Rpc_members_t m;
	Self =  tb_newParent(RPC_T);

	Self->isA  = RPC_T;

	m = (Rpc_members_t)tb_xcalloc(1, sizeof(struct Rpc_members));
	Self->members->instance = m;

	/*  [... generic ctor code here (members init)...]	*/
	m->methods = tb_HashX(KT_INT, 0);
	TB_DOCK(m->methods);
	if(fm->dbg) fm_addObject(Self);

	return Self;
}

void *Rpc_free(Rpc_t Self) {
	if(tb_valid(Self, RPC_T, __FUNCTION__)) {
    Rpc_members_t m = XRpc(Self);
		fm_fastfree_on();

		TB_UNDOCK(m->methods);
		tb_Free(m->methods);

		tb_freeMembers(Self);
		fm_fastfree_off();
		Self->isA = RPC_T; // requiered for introspection (as we are unwinding dtors stack)
    return tb_getParentMethod(Self, OM_FREE);
	}

  return NULL;
}


int Rpc_registerMethod(Rpc_t Self, rpc_sig_t methodSignature) {
	return tb_Insert(XRpc(Self)->methods, tb_Pointer(methodSignature, NULL), methodSignature->methodId);
}

rpc_sig_t Rpc_getMethod(Rpc_t Self, int methodId) {
	Pointer_t P = tb_Get(XRpc(Self)->methods, methodId);
	if(P) {
		return (rpc_sig_t)P2p(P);
	} else {
		tb_error("Rpc_getMethod[%d] : no such method !\n", methodId);
	}
	return NULL;
}
